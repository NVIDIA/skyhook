# SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Agent CI
on:
  pull_request:
    branches:
      - main
    paths:
      - agent/**
      - containers/agent.Dockerfile
      - .github/workflows/agent-ci.yaml
  push:
    branches:
      - main
    tags:
      - agent/*
    paths:
      - agent/**
      - containers/agent.Dockerfile
      - .github/workflows/agent-ci.yaml
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PYTHON_VERSION: 3.13
  DEBIAN_VERSION: trixie
jobs:
  fetch-distroless-versions:
    name: Fetch Latest Distroless Versions
    runs-on: ubuntu-latest
    outputs:
      distroless-version: ${{ steps.fetch.outputs.distroless-version }}
    steps:
      - name: Fetch versions from NVIDIA CDN
        id: fetch
        run: |
          # Fetch the versions.json file
          VERSIONS_JSON=$(curl -fsSL https://developer.download.nvidia.com/distroless-oss/versions.json)
          
          # Extract latest Python v4 version (format: "v4.0.1" -> "4.0.1")
          DISTROLESS_VERSION=$(echo "$VERSIONS_JSON" | jq -r ".v4.python.\"${PYTHON_VERSION}\"" | sed 's/^v//')
          
          echo "distroless-version=${DISTROLESS_VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Python ${PYTHON_VERSION} v4 Distroless Version: ${DISTROLESS_VERSION}"
  
  compute-metadata:
    name: Compute Image Metadata
    runs-on: ubuntu-latest
    outputs:
      git-sha: ${{ steps.meta.outputs.git-sha }}
      agent-version: ${{ steps.meta.outputs.agent-version }}
      agent-image-tag: ${{ steps.meta.outputs.agent-image-tag }}
      tags: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Fetch all tags
        run: git fetch --tags --force
      - name: Compute metadata
        id: meta
        run: |
          export GIT_SHA=$(git rev-parse --short ${{ github.sha }})
          echo "git-sha=${GIT_SHA}" >> $GITHUB_OUTPUT
          
          case ${{ github.ref_type }} in
            branch)
                # The last tag + current git sha
                export AGENT_VERSION=$(git tag --list 'agent*' --sort=-v:refname | head -n 1 | cut -d/ -f2)+${GIT_SHA}
                # Convert + to - for docker tag compliance
                export AGENT_IMAGE_TAG=$(echo "${AGENT_VERSION}" | tr + -)
                TAGS="${GIT_SHA} ${AGENT_IMAGE_TAG}"
                ;;
            tag)
                # The version part of the tag
                export AGENT_VERSION=$(echo "${{ github.ref_name }}" | cut -f 2 -d /)
                export AGENT_IMAGE_TAG="${AGENT_VERSION}"
                TAGS="${GIT_SHA} ${AGENT_VERSION} latest"
                ;;
            *)
                echo "Unknown type ${{ github.ref_type }}"
                exit 1
                ;;
          esac
          
          echo "agent-version=${AGENT_VERSION}" >> $GITHUB_OUTPUT
          echo "agent-image-tag=${AGENT_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Agent Version: ${AGENT_VERSION}"
          echo "ðŸ·ï¸  Image Tag: ${AGENT_IMAGE_TAG}"
          echo "ðŸ·ï¸  All Tags: ${TAGS}"
  
  test:
    name: Skyhook Agent Unit Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      checks: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Run unittests
        run: |
          cd agent
          make test
      - name: Generate Summary
        uses: test-summary/action@v2
        if: always()
        with:
          paths: "agent/skyhook-agent/test-results.xml"
          output: test-summary.md
      - name: Display Summary
        if: always()
        run: |
          cat test-summary.md >> $GITHUB_STEP_SUMMARY
  # Build container images on native architecture runners (much faster than QEMU)
  build-agent:
    runs-on: ${{ matrix.runner }}
    needs: [test, compute-metadata, fetch-distroless-versions] # Don't run the build and push if the unit tests fail
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Fetch all tags
        run: git fetch --tags --force
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build and tag container image for single platform on native hardware
      - name: Build the agent container image (${{ matrix.platform }})
        id: build
        env:
          GIT_SHA: ${{ needs.compute-metadata.outputs.git-sha }}
          AGENT_VERSION: ${{ needs.compute-metadata.outputs.agent-version }}
        run: |
          cd agent
          PLATFORM_TAG=$(echo "${{ matrix.platform }}" | tr '/' '-')
          
          # Lowercase for Docker compliance
          IMAGE_NAME=$(echo "${{env.IMAGE_NAME}}" | tr '[:upper:]' '[:lower:]')
          REGISTRY=$(echo "${{env.REGISTRY}}" | tr '[:upper:]' '[:lower:]')
          
          # Build platform-specific tags for all target tags
          TAGS=""
          for TAG in ${{ needs.compute-metadata.outputs.tags }}; do
            TAGS="$TAGS -t ${REGISTRY}/${IMAGE_NAME}/agent:${TAG}-${PLATFORM_TAG}"
          done
          
          set -x
          docker buildx build \
            --build-arg GIT_SHA=${GIT_SHA} \
            --build-arg AGENT_VERSION=${AGENT_VERSION} \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg DEBIAN_VERSION=${{ env.DEBIAN_VERSION }} \
            --build-arg DISTROLESS_VERSION=${{ needs.fetch-distroless-versions.outputs.distroless-version }} \
            --push \
            --platform ${{ matrix.platform }} \
            --provenance=false \
            ${TAGS@L} \
            --metadata-file=metadata.json \
            -f ../containers/agent.Dockerfile .
          
          echo "digest=$(cat metadata.json | jq -r .\"containerimage.digest\")" >> $GITHUB_OUTPUT

  # Create multi-platform manifest from individual architecture builds
  create-manifest:
    runs-on: ubuntu-latest
    needs: [compute-metadata, build-agent]
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Create and push multi-platform manifests, then delete platform-specific tags
      - name: Create manifests and cleanup
        id: manifest
        run: |
          # Lowercase for Docker compliance
          IMAGE_NAME=$(echo "${{env.IMAGE_NAME}}" | tr '[:upper:]' '[:lower:]')
          REGISTRY=$(echo "${{env.REGISTRY}}" | tr '[:upper:]' '[:lower:]')
          
          # Create manifest for each tag combining amd64 and arm64 images
          for TAG in ${{ needs.compute-metadata.outputs.tags }}; do
            FULL_TAG="${REGISTRY}/${IMAGE_NAME}/agent:${TAG}"
            echo "ðŸ“¦ Creating manifest for $FULL_TAG"
            docker manifest create $FULL_TAG \
              ${FULL_TAG}-linux-amd64 \
              ${FULL_TAG}-linux-arm64
            docker manifest push $FULL_TAG
            echo "âœ… Pushed $FULL_TAG"
          done
          
          # Get digest of the main tag (git sha) for attestation
          MAIN_TAG="${REGISTRY}/${IMAGE_NAME}/agent:${{ needs.compute-metadata.outputs.git-sha }}"
          DIGEST=$(docker manifest inspect $MAIN_TAG | jq -r '.manifests[0].digest')
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "subject-name=${REGISTRY}/${IMAGE_NAME}/agent" >> $GITHUB_OUTPUT
          
          # Note: Platform-specific tags (e.g., v1.0.0-linux-amd64) are left in registry
          # as intermediate artifacts. Users should pull the multi-platform manifest tags.
          # GitHub Container Registry doesn't easily support programmatic tag deletion.
          echo "âœ… Multi-platform manifests created successfully"
      
      # Generate supply chain security attestation for the multi-platform manifest
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ steps.manifest.outputs.subject-name }}
          subject-digest: ${{ steps.manifest.outputs.digest }}
          push-to-registry: true
  
  operator-agent-tests:
    name: Operator Agent Integration Tests
    runs-on: ubuntu-latest
    needs: [compute-metadata, create-manifest]
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-tags: true
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.6'
          cache-dependency-path: operator/go.sum
      
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create Kubernetes KinD Cluster
        uses: helm/kind-action@v1
        with:
          version: v0.31.0
          node_image: kindest/node:v1.35.0
          config: operator/config/local-dev/kind-config.yaml
          cluster_name: kind
      
      - name: Restore cached Binaries
        id: cached-binaries
        uses: actions/cache/restore@v4
        with:
          key: 1.25.6-${{ runner.os }}-${{ runner.arch }}-bin-${{ hashFiles('operator/deps.mk') }}
          restore-keys: 1.25.6-${{ runner.os }}-${{ runner.arch }}-bin-
          path: |
            ${{ github.workspace }}/operator/bin
            ~/.cache/go-build
      
      - name: Install dependencies
        if: steps.cached-binaries.outputs.cache-hit != 'true'
        run: |
          cd operator
          make install-deps
      
      - name: Save cached Binaries
        if: steps.cached-binaries.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          key: 1.25.6-${{ runner.os }}-${{ runner.arch }}-bin-${{ hashFiles('operator/deps.mk') }}
          path: |
            ${{ github.workspace }}/operator/bin
            ~/.cache/go-build
      
      - name: Run operator-agent tests
        env:
          AGENT_IMAGE: ${{ format('{0}/{1}/agent:{2}', env.REGISTRY, github.repository, needs.compute-metadata.outputs.agent-image-tag) }}
        run: |
          cd operator
          export AGENT_IMAGE="${AGENT_IMAGE,,}"
          echo "Testing with agent image: ${AGENT_IMAGE}"
          make build-cli
          make setup-kind-cluster operator-agent-tests
