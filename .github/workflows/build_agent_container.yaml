name: Build and push container image

# Configures this workflow to run every time a tag is created
on:
  push:
    branches: 
      - main
    paths:
      - agent/**
      - .github/workflows/build_agent_container.yaml

# NOTE: we may want to switch to matrix build for multi-platform support if this is taking too long
# https://docs.docker.com/build/ci/github-actions/multi-platform/#distribute-build-across-multiple-runners


# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_CMD: docker

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-agent:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      # 
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Setup for multi-platform
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build the agent container image
        id: build
        run: |
          apt-get update && apt-get install -y make git jq
          cd agent
          export TAGS="-t ${REGISTRY@L}/${{env.IMAGE_NAME}}/agent:${{ github.sha }}"
          export REGISTRY=${REGISTRY@L}
          # Get the last tag and use it as the env var AGENT_VERSION if it doesn't exist use 0.0.0+{github.sha}
          export AGENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0+${{ github.sha }}")
          make docker-build-only agent_version=${AGENT_VERSION}
          cat metadata.json
          echo "digest=$(cat metadata.json | jq -r .\"containerimage.digest\")" >> $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT
        env:
          AGENT_IMAGE: ${{env.IMAGE_NAME}}/agent
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [AUTOTITLE](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds). 
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{env.IMAGE_NAME}}/agent
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true
      
  build-and-publish-agentless:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Setup for multi-platform
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build the agent container image
        id: build
        run: |
          source ./containers/agentless/versions.sh
          cd agent
          export TAGS=()
          for version in $TEST_VERSIONS; do
            TAGS+="-t ${{ env.REGISTRY }}/${{env.IMAGE_NAME}}/agentless:$version "
          done

          docker buildx build --push --platform linux/amd64,linux/arm64 $TAGS --metadata-file=metadata.json -f ../containers/agentless/Dockerfile ../containers/agentless

          cat metadata.json
          echo "digest=$(cat metadata.json | jq -r .\"containerimage.digest\")" >> $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [AUTOTITLE](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds). 
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{env.IMAGE_NAME}}/agentless
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true